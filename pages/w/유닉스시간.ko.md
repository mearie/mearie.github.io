---
title: 유닉스 시간
short: unxt
...

[[유닉스]] 계열, 또는 [[POSIX]]를 준수하는 [[운영체제]]에서 사용하는 [[시각]] 표기. 일반적으로 유닉스 시간이라고 하는 것은 [[C언어]]에서 `time_t`의 값으로, 표준 C에서는 이 값의 의미를 전혀 정의하지 않지만^[심지어 [[단조증가]]하지 않아도 적법하며, 실제로 POSIX 표준에 따르면 윤초가 추가될 때 유닉스 시간은 단조증가하지 않는다.] POSIX에서는 이 값을 명확히 정의하고 있다. 정확한 정의는:

> 1970-01-01T00:00:00Z [[UTC]]로 정의된 [[기원]]으로부터 지난 시간을 [[초]] 단위로 **근사**하는 값^[POSIX:2001 이후의 정의. 이전 버전은 [[윤년]]에 대한 처리에 큰 문제가 있었다.]

이다. 이 정의가 UTC와 일대일 대응이 되지 않고 근사하도록 정의된 이유는 유닉스 시간을 [[윤초]]를 무시하고 UTC 표현으로부터 간단한 계산만으로 구할 수 있도록 되어 있기 때문이다. 그러하니 당연히 윤초가 추가될 때는 윤초 직전의 초와 윤초의 유닉스 시간 값이 겹치고, 윤초가 빠질 때는 빠진 윤초에 해당하는 유닉스 시간 값을 건너 뛰게 된다. 윤초를 건너 뛰는 것 뿐만이 아니라 현재 기원(1970년)은 UTC가 현재의 형태로 정착된 때(1972년)보다 이전이라 1972년 이전에 해당하는 유닉스 시간은 잘 정의되어 있지 않다고 할 수 있다.

이런 저런 문제에도 불구하고 유닉스 시간은 유닉스 계열 운영체제 뿐만 아니라 많은 [[프로그래밍 언어]]와 [[파일 포맷]], [[프로토콜]] 등에서 사용하고 있다. 이 중 32[[비트]]로 유닉스 시간을 표현하는 시스템에서는 "2038년 문제"라 불리는 [[Y2K]] 뺨치는 문제가 생길 예정이다. (`time_t`가 [[부호없는 정수]]이면 좀 더 시간을 벌 수 있겠지만, 호환성 등의 문제로 보통 부호 있는 정수를 쓰기 때문에 시간을 벌기는 어렵다.)

# 오버플로

유닉스 시간이 특정 값을 넘겼을 때 생기는 문제는 [[소프트웨어]] [[버그]]의 온상이 되고 있다. 예를 들어,

* 유닉스 시간 10 0000 0000([[2001]]-09-09T01:46:40Z)은 처음으로 유닉스 시간이 [[십진법]] 열자리가 된 때이다. 덕택에 [[Iris NX]] 같이 유닉스 시간을 문자열로 인코딩해서 정렬하는 소프트웨어들이 모조리 순서를 엉터리로 표시하는 문제를 겪었다.
* 유닉스 시간 2^31^ = 21 4748 3648(2038-01-19T03:14:07Z)은 유닉스 시간이 32[[비트]] [[2의 보수]] 표현으로 더 이상 표현 불가능한, 즉 [[오버플로]]되는 때이다. 그 때까지 문제를 해결 못 한 소프트웨어에서는 각종 "2038년 문제"가 발생할 예정이다.
	* 유닉스 시간 2^31^-10^9^ = 11 4748 3648([[2006]]-05-13T01:27:28Z)에 AOLServer의 기본 설정이 문제를 일으키는 [사례](http://www.mail-archive.com/aolserver@listserv.aol.com/msg09812.html)가 있었다. 이 사건은 2038년 문제의 첫 사례로 기록되었다.

