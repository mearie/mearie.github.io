<!doctype html>
<!--[if gt IE 8]>--><html lang="ko"><!--<![endif]--><!--[if lte IE 8]><html lang="ko" class="mearie-ancient"><![endif]-->
<head>
<meta charset="utf-8">
<title>비트 연산 | 메아리</title>
<meta name="viewport" content="initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<link rel="canonical" href="/w/비트연산.ko" />
<link rel="shortlink" href="/bito" />
<link rel="shortcut icon" href="/favicon.ico" type="image/vnd.microsoft.icon" />
<!--[if gt IE 6]><![IGNORE[-->
<script src="/res/mearie.js"></script>
<link rel="stylesheet" href="/res/main.css" />
<!--<![endif]-->
</head>
<body>
<header>
<div id="mearie-logo">
<a href="/index.ko" rel="home">
<svg version="1.0" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 182 186">
<path d="M0 0h54v102h-35v52h35v32h-54m34-70h20v24h-20" />
<path d="M64 0h54v100a22 22 0 0 0 0 56v30h-54m54-72a12 12 0 0 0 0 28v-28" />
<path d="M128 0h54v102h-33v12h33v8h-33v32h33v32h-54m35-52h19v8h-19" />
</svg>
 메아리</a>
</div>
<h1><span class="parent"><a href="/w/index.ko">낱말들</a><br /></span>비트 연산</h1>
</header>
<main role="main">
<p>여러 개의 <a title="→ 비트" data-dead-href="/w/%EB%B9%84%ED%8A%B8.ko" class="keyword dead">비트</a>로 이루어진 값(흔히 비트 갯수가 정해진 <a href="/w/%EC%9D%B4%EC%A7%84%EC%88%98.ko" title="→ 이진수" class="keyword">이진수</a>일 때가 많다)을 다루기 위한 연산들.</p>
<a name="more"><!-- more --></a>
<h2><span class="header-section-number">1</span> 비트별 연산</h2>
<p>Bitwise operation. <a title="→ 한국어" data-dead-href="/w/%ED%95%9C%EA%B5%AD%EC%96%B4.ko" class="keyword dead">한국어</a>에서는 비트“별” 연산과 비트 연산을 크게 구분하지 않는 것 같지만, 비트별 연산은 두 값에 대해서 대응되는 비트들끼리만 연산이 일어나고 위치가 같지 않아 대응되지 않는 비트들끼리는 연산이 일어나지 않는다는 점에서 비트 연산의 하위 개념이다.</p>
<p>여기에 속하는 연산들은 <a title="→ 논리연산" data-dead-href="/w/%EB%85%BC%EB%A6%AC%EC%97%B0%EC%82%B0.ko" class="keyword dead">논리 연산</a>과 밀접한 관계를 맺고 있으며, 그 성질 또한 대응되는 논리 연산과 정확히 일치한다.</p>
<dl>
<dt>비트 NOT</dt>
<dd><a title="→ 논리부정" data-dead-href="/w/%EB%85%BC%EB%A6%AC%EB%B6%80%EC%A0%95.ko" class="keyword dead">논리부정</a>에 대응되며, 흔히 <code>~</code>나 <code>^</code> 단항 연산자로 나타낸다. <a title="→ 2의보수" data-dead-href="/w/2%EC%9D%98%EB%B3%B4%EC%88%98.ko" class="keyword dead">2의 보수</a> 체계로 표현된 숫자의 경우, 어떤 수를 비트 NOT 한 결과는 해당 숫자의 부호를 바꾼 뒤 1을 뺀 것과 같다(<a title="→ c-언어" data-dead-href="/w/c-%EC%96%B8%EC%96%B4.ko" class="keyword dead">C 언어</a>로 치자면 <code>~x == -x - 1</code>).</dd>
<dt>비트 AND</dt>
<dd><a title="→ 논리곱" data-dead-href="/w/%EB%85%BC%EB%A6%AC%EA%B3%B1.ko" class="keyword dead">논리곱</a>에 대응되며, 흔히 <code>&amp;</code> 이항 연산자로 나타낸다. 크게 두 가지 사용 용도가 있다:
* 특정 비트가 설정되었는지 아닌지를 확인하려면, 확인할 비트만 설정된 숫자와 비트 AND를 해서 그 결과가 0이 아닌지 0인지 확인하면 된다. 이 때 확인할 비트만 설정된 숫자를 흔히 “비트 마스크”(bitmask)라 부른다.
* 특정 비트를 0으로 설정하고 다른 비트를 그대로 유지할 경우, 확인할 비트만 <strong>빼고</strong> 모든 비트가 설정된 숫자와 비트 AND를 하면 된다. 이 경우 비트 NOT과 함께 쓰이기도 한다.</dd>
<dt>비트 OR</dt>
<dd><a title="→ 논리합" data-dead-href="/w/%EB%85%BC%EB%A6%AC%ED%95%A9.ko" class="keyword dead">논리합</a>에 대응되며, 흔히 <code>|</code> 이항 연산자로 나타낸다. 특정 비트를 1로 설정하고 다른 비트를 그대로 유지할 때 쓰는데, 해당 비트만 설정된 숫자와 비트 OR을 하면 된다.</dd>
<dt>비트 XOR</dt>
<dd><a title="→ 배타적논리합" data-dead-href="/w/%EB%B0%B0%ED%83%80%EC%A0%81%EB%85%BC%EB%A6%AC%ED%95%A9.ko" class="keyword dead">배타적 논리합</a>에 대응되며, 흔히 <code>^</code> 이항 연산자로 나타낸다. 특정 비트를 반전시키고 다른 비트를 그대로 유지할 때 쓰며(비트 OR과 같은 방법), 같은 숫자와 XOR을 두 번 하면 원래 숫자로 돌아 오기 때문에(<code>(x ^ y) ^ y == x</code>) <a title="→ xor-교환알고리즘" data-dead-href="/w/xor-%EA%B5%90%ED%99%98%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.ko" class="keyword dead">XOR 교환 알고리즘</a>이나 <a title="→ xor-연결리스트" data-dead-href="/w/xor-%EC%97%B0%EA%B2%B0%EB%A6%AC%EC%8A%A4%ED%8A%B8.ko" class="keyword dead">XOR 연결 리스트</a> 등에서 사용하기도 한다.</dd>
</dl>
<h2><span class="header-section-number">2</span> 비트 시프트</h2>
<p>Bit shift. 개별 비트는 그대로 유지한 채 그 위치만 수평으로 바꾸는 연산들을 일컫는다.</p>
<p>이 연산들은 흔히 “시프트할 비트 수”를 그 인자로 받는데, 왼쪽 또는 오른쪽으로 한 칸 움직이는 시프트를 그 횟수만큼 반복 수행하는 것으로 단항 연산자로 만들 수 있다. 이 경우 시프트를 한 뒤에 한 쪽 끝으로 삐져나간 비트는 사라지며, 대신 다른 한 쪽 끝에서 모자라는 비트를 어떻게 채울지를 가지고 연산자들을 분류할 수 있다.</p>
<dl>
<dt>산술 시프트</dt>
<dd>Arithmetic shift. 오른쪽으로 시프트할 때는 원래 왼쪽 끝에 있던 비트를 왼쪽 빈 자리에 넣고, 왼쪽으로 시프트할 때는 오른쪽 끝에 0을 집어 넣는다. “산술” 시프트라 불리는 이유는 이 연산이 부호 있는 정수의 2로 나누기(오른쪽 시프트)나 2로 곱하기(왼쪽 시프트)와 연관이 있기 때문이다. (다만 <a title="→ 1의보수" data-dead-href="/w/1%EC%9D%98%EB%B3%B4%EC%88%98.ko" class="keyword dead">1의 보수</a> 표현에서는 2로 나눌 때 절삭 방향이 약간 달라진다.) 흔히 <code>&lt;&lt;</code> 및 <code>&gt;&gt;</code> 이항 연산자로 나타내며, 연산자 오른쪽이 시프트할 비트 수를 가리킨다.</dd>
<dt>논리 시프트</dt>
<dd>Logical shift. 오른쪽으로 시프트할 때나 왼쪽으로 시프트할 때나 빈 자리에 0을 집어 넣는다. 산술 시프트와 비슷하게, 이 연산은 부호 없는 정수의 2로 나누기나 2로 곱하기에 대응된다. 오른쪽 산술 시프트와 논리 시프트를 구분하는 언어의 경우 이 연산자는 흔히 <code>&gt;&gt;&gt;</code>로 쓰며, 구분하지 않을 경우 연산자 왼쪽이 부호가 있느냐 없느냐를 가지고 <code>&gt;&gt;</code>의 동작을 바꾸는 게 일반적이다. (왼쪽 시프트는 산술이나 논리나 똑같으므로 다른 연산자가 필요하지 않다.)</dd>
<dt>비트 회전</dt>
<dd>Bit rotation 또는 circular shift. 오른쪽으로 시프트할 때는 오른쪽으로 잘려 나간 비트를 왼쪽 빈 공간에 채우고, 왼쪽으로 시프트할 때는 왼쪽으로 잘려 나간 비트를 오른쪽 빈 공간에 채운다. 흔히 쓰이지는 않지만 모든 비트를 유지한 채 위치를 바꿀 때 종종 유용하며, <a title="→ 암호학" data-dead-href="/w/%EC%95%94%ED%98%B8%ED%95%99.ko" class="keyword dead">암호학</a>에서 특히 많이 쓰인다.</dd>
<dt>자리 올림을 포함한 비트 회전</dt>
<dd>보통 비트 회전과 비슷하지만 원래 비트들과 별개로 자리 올림(carry) 비트가 회전에 관여하다는 점이 다르다. 산술 시프트와 논리 시프트를 이 연산만으로 구현할 수 있기 때문에 (예를 들어서 오른쪽 논리 시프트의 경우 자리 올림에 0을 넣으면 된다) 일부 프로세서에서는 시프트는 없고 회전 두 종류만 있는 경우도 있다.</dd>
</dl>
<h2><span class="header-section-number">3</span> 기타 비트 연산</h2>
<p>아래 연산들은 흔히 나타나는 건 아니지만 종종 유용할 수도 있는(…) 그런 연산들이다.</p>
<dl>
<dt>비트 AND-NOT</dt>
<dd>비트 AND의 오른쪽 피연산자에 비트 NOT을 넣은 연산. <a title="→ go-언어" data-dead-href="/w/go-%EC%96%B8%EC%96%B4.ko" class="keyword dead">Go 언어</a>에서 <code>&amp;^</code> 이항 연산자로 지원한다.</dd>
<dt>비트 선택</dt>
<dd><p>특정 비트열에서 주어진 비트만 꺼내서 <strong>순서대로</strong> 나열하는 연산. 이 연산의 작동은 다음 그림으로 설명하는 것이 가장 빠르다:</p>
<pre><code>       1 0 1 0
select 1 0 0 1
--------------
       1     0 --&gt; 1 0</code></pre>
<p>이 연산은 비트 시프트의 일반화로 볼 수 있으나, 다른 비트 연산과는 달리 하드웨어에서 구현하는 경우가 별로 없어서 상당히 비싼 연산이다. <a title="→ intercal" data-dead-href="/w/intercal.ko" class="keyword dead">INTERCAL</a>에서 지원하는 몇 안 되는 연산 중 하나이며, <a title="→ mmix" data-dead-href="/w/mmix.ko" class="keyword dead">MMIX</a>가 이와 굉장히 유사한 명령(<code>SADD</code>)을 지원한다.</p></dd>
<dt>비트 확장</dt>
<dd>특정 비트열을 주어진 비트 위치에 재배치하는 연산. 비트 선택의 정 반대로 생각할 수 있으며, 마찬가지 이유로 상당히 비싼 연산이다. INTERCAL의 mingle 연산이 이 연산의 제약된 버전이다(<code>a $ b == (a expand ...1010) | (b expand ...0101)</code>).</dd>
<dt>비트 뒤집기</dt>
<dd>Bit reversal. <s><a title="→ 밥상뒤집기" data-dead-href="/w/%EB%B0%A5%EC%83%81%EB%92%A4%EC%A7%91%EA%B8%B0.ko" class="keyword dead">밥상 뒤집기</a></s> 말 그대로 비트열의 순서를 완전히 뒤집는 것. 매우 비싼 연산이자 매우 활용도가 높은 연산으로, <a title="→ 빠른푸리에변환" data-dead-href="/w/%EB%B9%A0%EB%A5%B8%ED%91%B8%EB%A6%AC%EC%97%90%EB%B3%80%ED%99%98.ko" class="keyword dead">빠른 푸리에 변환</a>(FFT)의 구현에 중요한 역할을 한다. 자세한 내용은 <a title="→ 비트뒤집기" data-dead-href="/w/%EB%B9%84%ED%8A%B8%EB%92%A4%EC%A7%91%EA%B8%B0.ko" class="keyword dead">비트 뒤집기</a>를 참고.</dd>
<dt>해밍 무게</dt>
<dd>Hamming weight 또는 population count. 주어진 비트열 안의 1 비트의 숫자를 가리킨다. 비트 뒤집기와 더불어 매우 비싼 연산이자 매우 활용도가 높은 연산으로, 자세한 내용은 <a title="→ 해밍무게" data-dead-href="/w/%ED%95%B4%EB%B0%8D%EB%AC%B4%EA%B2%8C.ko" class="keyword dead">해밍 무게</a>를 참고.</dd>
</dl>
<h2><span class="header-section-number">4</span> 같이 보기</h2>
<ul>
<li>《<a title="→ 해커의즐거움" data-dead-href="/w/%ED%95%B4%EC%BB%A4%EC%9D%98%EC%A6%90%EA%B1%B0%EC%9B%80.ko" class="keyword dead">해커의 즐거움</a>》 (기초적인 내용을 담은 2장이 웹사이트에 <a href="http://hackersdelight.org/basics.pdf">공개</a>되어 있다)</li>
</ul>
<h2><span class="header-section-number">5</span> 바깥 링크</h2>
<ul>
<li><a href="http://rigaux.org/language-study/syntax-across-languages/Mthmt.html#MthmtBtwsprtr">각종 프로그래밍 언어의 비트 연산 문법들</a></li>
</ul>
</main>
<footer>
<p id="mearie-meta"><code><i class="mearie-logo"></i>/bito</code> | 마지막 수정 <time>2016-05-29T19:22:13+0000</time> (<code>12e94c38778d</code>)</p>
<address>저작권자 &copy; 1999&ndash;2016, 강 성훈. <a href="/about/copyright.ko" rel="copyright">저작권을 약간 가집니다.</a></address>
</footer>
</body>
</html>
