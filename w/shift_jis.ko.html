<!doctype html>
<!--[if gt IE 8]>--><html lang="ko"><!--<![endif]--><!--[if lte IE 8]><html lang="ko" class="mearie-ancient"><![endif]-->
<head>
<meta charset="utf-8">
<title>Shift_JIS | 메아리</title>
<meta name="viewport" content="initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<link rel="canonical" href="/w/shift_jis.ko" />
<link rel="shortlink" href="/sjis" />
<link rel="shortcut icon" href="/favicon.ico" type="image/vnd.microsoft.icon" />
<!--[if gt IE 6]><![IGNORE[-->
<script src="/res/mearie.js"></script>
<link rel="stylesheet" href="/res/main.css" />
<!--<![endif]-->
</head>
<body>
<header>
<div id="mearie-logo">
<a href="/index.ko" rel="home">
<svg version="1.0" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 182 186">
<path d="M0 0h54v102h-35v52h35v32h-54m34-70h20v24h-20" />
<path d="M64 0h54v100a22 22 0 0 0 0 56v30h-54m54-72a12 12 0 0 0 0 28v-28" />
<path d="M128 0h54v102h-33v12h33v8h-33v32h33v32h-54m35-52h19v8h-19" />
</svg>
 메아리</a>
</div>
<h1><span class="parent"><a href="/w/index.ko">낱말들</a><br /></span>Shift_JIS</h1>
</header>
<main role="main">
<p><a title="→ 마이크로소프트" data-dead-href="/w/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%86%8C%ED%94%84%ED%8A%B8.ko" class="keyword dead">마이크로소프트</a>와 <a title="→ 주식회사아스키" data-dead-href="/w/%EC%A3%BC%EC%8B%9D%ED%9A%8C%EC%82%AC%EC%95%84%EC%8A%A4%ED%82%A4.ko" class="keyword dead">주식회사 아스키</a>가 합작해서 만든 <a title="→ 일본어" data-dead-href="/w/%EC%9D%BC%EB%B3%B8%EC%96%B4.ko" class="keyword dead">일본어</a> <a href="/w/%EB%AC%B8%EC%9E%90%EC%9D%B8%EC%BD%94%EB%94%A9.ko" title="→ 문자인코딩" class="keyword">문자 인코딩</a>. <a title="→ jis-x-0201" data-dead-href="/w/jis-x-0201.ko" class="keyword dead">JIS X 0201</a> 및 <a title="→ jis-x-0208" data-dead-href="/w/jis-x-0208.ko" class="keyword dead">JIS X 0208</a> <a href="/w/%EB%AC%B8%EC%9E%90%EC%A7%91%ED%95%A9.ko" title="→ 문자집합" class="keyword">문자 집합</a>을 지원하는 인코딩이지만, 그 모양새나 쓰임새나 여러 모로 문제가 많은(…) 인코딩이다. 그럼에도 불구하고 <a title="→ 마이크로소프트윈도" data-dead-href="/w/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%86%8C%ED%94%84%ED%8A%B8%EC%9C%88%EB%8F%84.ko" class="keyword dead">마이크로소프트 윈도</a>의 기본 인코딩이었기 때문에(정확히는, <a title="→ windows-31j" data-dead-href="/w/windows-31j.ko" class="keyword dead">Windows-31J</a>의 형태로) <a title="→ utf-8" data-dead-href="/w/utf-8.ko" class="keyword dead">UTF-8</a>이 나올 때까지는 매우 널리 쓰였다.</p>
<p>1982년 발표 당시에는 표준화 과정을 거치지 않은 <a title="→ 사실상의표준" data-dead-href="/w/%EC%82%AC%EC%8B%A4%EC%83%81%EC%9D%98%ED%91%9C%EC%A4%80.ko" class="keyword dead">사실상의 표준</a>(de facto standard)이었으나, 1997년 이후로 JIS X 0208 부속서 1에 “시프트 인코딩”이라는 이름으로 기술되면서 정식으로 표준화되었다. <a title="→ 상용조합형" data-dead-href="/w/%EC%83%81%EC%9A%A9%EC%A1%B0%ED%95%A9%ED%98%95.ko" class="keyword dead">상용 조합형</a>의 표준화 과정을 생각해 보면 비슷할 듯.</p>
<a name="more"><!-- more --></a>
<h2><span class="header-section-number">1</span> 배경</h2>
<p>Shift_JIS의 등장에는 슬픈 전설이 있다. <s>나는 전설 따위는 믿지 않아</s> 본래 <a title="→ 일본" data-dead-href="/w/%EC%9D%BC%EB%B3%B8.ko" class="keyword dead">일본</a>은 문자 전산화를 처음 할 때(무려 <strong>1960년대</strong>)만 해도 2바이트 인코딩을 위한 체계가 전혀 마련되어 있지 않았기 때문에 <a title="→ 가타카나" data-dead-href="/w/%EA%B0%80%ED%83%80%EC%B9%B4%EB%82%98.ko" class="keyword dead">가타카나</a>만을 1바이트 인코딩으로 넣어 버리게 되는데, 이게 바로 <a title="→ jis-x-0201" data-dead-href="/w/jis-x-0201.ko" class="keyword dead">JIS X 0201</a>(당시에는 JIS C 6220)이다.<a id="fnref1" class="footnote" href="#fn1"><sup><span>[</span>1<span>]</span></sup></a> 그런데 나중에 2바이트 인코딩으로 <a title="→ 히라가나" data-dead-href="/w/%ED%9E%88%EB%9D%BC%EA%B0%80%EB%82%98.ko" class="keyword dead">히라가나</a>, 가타카나 및 <a title="→ 칸지" data-dead-href="/w/%EC%B9%B8%EC%A7%80.ko" class="keyword dead">칸지</a>를 모두 담은 <a title="→ jis-x-0208" data-dead-href="/w/jis-x-0208.ko" class="keyword dead">JIS X 0208</a>(당시에는 JIS C 6226)이 나오는데, 본래의 의도대로라면 JIS X 0208은 JIS X 0201을 “대체”하는 표준이 되었어야 했지만 기존에 작성된 문서가 전혀 호환되지 않는 심각한 문제가 발생하고 만다. 게다가 JIS X 0208은 흔히 볼 수 있는 <a title="→ 94x94" data-dead-href="/w/94x94.ko" class="keyword dead">94x94</a> 문자 집합임에도 불구하고 JIS X 0201이 이미 GR 영역(<code>A0</code>–<code>FF</code>)을 일부 사용하고 있어서 간단하게 붙여 넣을 수가 없었다. (<a href="/w/ks-x-1001.ko" title="→ ks-x-1001" class="keyword">KS X 1001</a>이 <a title="→ ks-x-1003" data-dead-href="/w/ks-x-1003.ko" class="keyword dead">KS X 1003</a>과 말끔하게 결합하여 <a href="/w/euc-kr.ko" title="→ euc-kr" class="keyword">EUC-KR</a>이 되는 것과는 대조적이다.)</p>
<p>그래서 JIS X 0201에서 할당되지 않은 65개의 바이트를 첫 바이트로 하고, 둘째 바이트의 범위를 크게 늘려 잡아서 JIS X 0208을 인코딩하는 꼼수를 쓴 것이 바로 Shift_JIS이다. “시프트”라는 이름은 JIS X 0208의 행 번호를 1비트 오른쪽 <a title="→ 비트시프트" data-dead-href="/w/%EB%B9%84%ED%8A%B8%EC%8B%9C%ED%94%84%ED%8A%B8.ko" class="keyword dead">시프트</a>하여 첫 바이트를 정한 점에서 유래한다. 행 번호의 맨 아래 1비트는 열 번호에 합쳐서 두번째 바이트에 인코딩하는데, 이 때문에 두번째 바이트는 94×2 = 188개의 문자를 인코딩해야 했다. 이 때문에 GR 영역은 물론이고 CR(<code>80</code>–<code>9F</code>) 및 GL(<code>20</code>–<code>7F</code>) 영역 대부분을 함께 써야 했는데, 물론 온갖 문제가 일어나게 된다. 십수년 뒤에 나온 <a href="/w/windows-949.ko" title="→ windows-949" class="keyword">Windows-949</a>에서도 사실상 같은 접근이 쓰이긴 했지만, Shift_JIS에서 엄청나게 데인 마이크로소프트는 두번째 바이트의 범위를 잘 조정하여 호환성 문제를 상당수 피해 갔다.</p>
<p>이런 혼란은 기본적으로는 일본이 <a title="→ 한중일" data-dead-href="/w/%ED%95%9C%EC%A4%91%EC%9D%BC.ko" class="keyword dead">한중일</a> 삼국 중 문자 전산화를 가장 먼저 시작했기 때문에 벌어진 것이지만, 결과적으로는 후술할 문제들 때문에 널리 쓰이긴 해도 완벽하게 다른 모든 인코딩을 대체할 수는 없었다. Shift_JIS는 <a title="→ dos-v" data-dead-href="/w/dos-v.ko" class="keyword dead">DOS V</a> 및 <a title="→ 마이크로소프트윈도" data-dead-href="/w/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%86%8C%ED%94%84%ED%8A%B8%EC%9C%88%EB%8F%84.ko" class="keyword dead">마이크로소프트 윈도</a>에서, <a title="→ euc-jp" data-dead-href="/w/euc-jp.ko" class="keyword dead">EUC-JP</a>는 <a title="→ 유닉스" data-dead-href="/w/%EC%9C%A0%EB%8B%89%EC%8A%A4.ko" class="keyword dead">유닉스</a> 계열 운영체제에서, 그리고 <a title="→ iso-2022-jp" data-dead-href="/w/iso-2022-jp.ko" class="keyword dead">ISO-2022-JP</a>는 플랫폼 독립적인 상황(<a title="→ html" data-dead-href="/w/html.ko" class="keyword dead">HTML</a> 및 <a title="→ mime" data-dead-href="/w/mime.ko" class="keyword dead">MIME</a>)에서 오랫동안 널리 쓰였다. 또한 마이크로소프트는 <a title="→ 한중일" data-dead-href="/w/%ED%95%9C%EC%A4%91%EC%9D%BC.ko" class="keyword dead">한중일</a> 문자 인코딩을 모두 자체적으로 재정의했음에도 불구하고 일본어 인코딩만큼은 다른 회사와 보조를 맞출 수 밖에 없었다(게다가 인코딩 설계에 결정적인 역할도 담당하지 못 했다).</p>
<h2><span class="header-section-number">2</span> 구조</h2>
<p>JIS X 0201이 할당하고 있던 GR 영역 바이트는 <code>A1</code>부터 <code>DF</code>까지로, Shift_JIS의 첫 바이트는 이 영역을 피하여 할당되어 있다. 즉:</p>
<ul>
<li>1행 및 2행에 속하는 문자는 <code>81</code>을 첫 바이트로,</li>
<li>3행 및 4행에 속하는 문자는 <code>82</code>를 첫 바이트로,</li>
<li>…</li>
<li>61행 및 62행에 속하는 문자는 <code>9F</code>를 첫 바이트로,</li>
<li>63행 및 64행에 속하는 문자는 <code>E0</code>을 첫 바이트로,</li>
<li>…</li>
<li>93행 및 94행에 속하는 문자는 <code>EF</code>를 첫 바이트로 한다.</li>
</ul>
<p>Shift_JIS의 둘째 바이트는 JIS X 0208에서 두 행에 속하는 188개의 문자를 적절히 쪼개서 할당되어 있다. 즉:</p>
<ul>
<li>홀수행이면서 1열부터 63열까지에 속하는 문자는 순서대로 <code>40</code>부터 <code>7E</code>까지를 둘째 바이트로,</li>
<li>홀수행이면서 64열부터 94열까지에 속하는 문자는 순서대로 <code>80</code>부터 <code>9E</code>까지를 둘째 바이트로,</li>
<li>짝수행이면서 1열부터 94열까지에 속하는 문자는 순서대로 <code>9F</code>부터 <code>FC</code>까지를 둘째 바이트로 한다.</li>
</ul>
<p>…이걸로 설명이 끝나면 참 좋을텐데, 현실은 그렇지 않다. Shift_JIS에는 확장의 여지가 두 군데 남아 있는데, 일단 JIS X 0208에서 할당되지 않고 남아 있는 영역들(9–15행 및 85–94행)이 있고 Shift_JIS에서 첫 바이트로 사용하지 않는 <code>F0</code>부터 <code>FF</code>까지의 영역들이 있다. 후자의 경우 JIS X 0208을 95행 이후로 확장했을 경우를 상정해서 95–126행이라고 부르기도 한다. 이 남아 있는 공간들이 워낙 큰데다가, 일본어의 경우 기존 인코딩으로 표현이 불가능한 가이지(外字)의 수요가 높기 때문에 똑같은 Shift_JIS를 쓴다 하더라도 확장된 문자들에 따라서 인코딩이 달라지는 경우가 흔하다. 다음은 Shift_JIS의 주요 확장들과 확장된 문자들의 목록이다:</p>
<ul>
<li><a title="→ ibm" data-dead-href="/w/ibm.ko" class="keyword dead">IBM</a> <a title="→ 코드페이지" data-dead-href="/w/%EC%BD%94%EB%93%9C%ED%8E%98%EC%9D%B4%EC%A7%80.ko" class="keyword dead">코드페이지</a> 932: 115–119행에 자체 문자 집합에서 JIS X 0208에 포함되지 않은 한자 및 특수 문자를 추가. 후에 <a title="→ dos-v" data-dead-href="/w/dos-v.ko" class="keyword dead">DOS V</a>에서 사용된다.</li>
<li><a title="→ nec" data-dead-href="/w/nec.ko" class="keyword dead">NEC</a> <a title="→ pc-9800" data-dead-href="/w/pc-9800.ko" class="keyword dead">PC-9800</a>: IBM 확장 문자를 115–119행에서 89–92행으로 옮기고, 9–13행에 NEC 자체 문자 집합(JIPS GL영역)에 있던 특수 문자를 추가.</li>
<li><a title="→ windows-31j" data-dead-href="/w/windows-31j.ko" class="keyword dead">Windows-31J</a>: <a title="→ 윈도3.1" data-dead-href="/w/%EC%9C%88%EB%8F%843.1.ko" class="keyword dead">윈도 3.1</a> 이후로 사용되기 시작한 <a title="→ 마이크로소프트" data-dead-href="/w/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%86%8C%ED%94%84%ED%8A%B8.ko" class="keyword dead">마이크로소프트</a> 확장. 당시 가장 널리 쓰이던 OEM 문자 집합인 IBM 및 NEC 확장을 합친 것으로, 덕분에 <strong>IBM 확장 문자는 두 번 중복으로 들어 간다</strong>.<a id="fnref2" class="footnote" href="#fn2"><sup><span>[</span>2<span>]</span></sup></a></li>
<li><a title="→ macjapanese" data-dead-href="/w/macjapanese.ko" class="keyword dead">MacJapanese</a>: 위에 나온 것들과 완전히 다른 확장이다(…). 9–15행에 특수 문자를, 85–89행에 <a title="→ 세로쓰기" data-dead-href="/w/%EC%84%B8%EB%A1%9C%EC%93%B0%EA%B8%B0.ko" class="keyword dead">세로쓰기</a>를 위한 90도 회전 문자를 배치했으며, JIS X 0201에서 할당되지 않았지만 Shift_JIS에서도 사용하지 않는 <code>80</code>, <code>A0</code>, <code>FD</code>–<code>FF</code>에 문자가 더 추가되었다.</li>
<li><a title="→ ntt-도코모" data-dead-href="/w/ntt-%EB%8F%84%EC%BD%94%EB%AA%A8.ko" class="keyword dead">NTT 도코모</a> <a title="→ i-mode" data-dead-href="/w/i-mode.ko" class="keyword dead">i-mode</a>: PC-9800 확장에서 13행만 가져 오고, 이와는 별개로 112–114행에 자체적으로 사용하는 <a title="→ 에모지" data-dead-href="/w/%EC%97%90%EB%AA%A8%EC%A7%80.ko" class="keyword dead">에모지</a>를 추가하고 있다.</li>
<li>Shift_JIS가 너무 많이 쓰이다 보니까 <strong>표준안까지도 Shift_JIS 확장을 염두에 두고 문자 위치를 정하기까지 한다</strong>. <a title="→ jis-x-0213" data-dead-href="/w/jis-x-0213.ko" class="keyword dead">JIS X 0213</a>의 제 2면은 잘 구겨 넣으면 95–120행에 들어 가는데, 표준안에 아예 어떻게 구겨 넣는지 명세가 되어 있다(…). 물론 실질적으로는 다른 확장들이 너무 널리 쓰여서 그리 많이 쓰이진 않는다.</li>
</ul>
<p>여기서 볼 수 있듯이, 똑같은 Shift_JIS라 하더라도 확장에 대해서는 완전히 다른 결과가 나올 수 있다.<a id="fnref3" class="footnote" href="#fn3"><sup><span>[</span>3<span>]</span></sup></a></p>
<h2><span class="header-section-number">3</span> 문제점</h2>
<p>확장 영역으로 인한 호환성은 둘째치고라도, Shift_JIS는 특히 문자열 처리에 매우 취약하다. 여타 다른 멀티바이트 문자 인코딩이라고 안 그렇다는 건 아니지만 이 쪽은 그 정도가 특히 심하다. 예를 들어서:</p>
<ul>
<li>문자열을 뒤에서부터나 중간에서 한 글자씩 제거하는 것이 매우 어렵다. 두번째 바이트가 ASCII랑 겹치는 경우가 있어서 그런데, 이게 안 되면 문자열을 주어진 바이트 크기 안으로 잘라서 맞추는 게 삽질이 된다.</li>
<li>비슷한 이유로 인코딩된 문자열에 오류가 있을 때 오류를 바로 잡기 어렵다. 어떤 문자가 보통의 ASCII 문자인지, 아니면 2바이트 열의 두번째 바이트만 남은 것인지 확인하기 특히 어렵다.</li>
<li>좀 더 심각한 문제로, <a title="→ 마이크로소프트윈도" data-dead-href="/w/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%86%8C%ED%94%84%ED%8A%B8%EC%9C%88%EB%8F%84.ko" class="keyword dead">마이크로소프트 윈도</a>에서 디렉토리 구분자로 쓰이는 <code>\</code>(0x5c)가 보통 문자열 <code>\</code> 말고 바이트열 속에 <code>5C</code>가 들어갈 경우 단순한 바이트 비교로는 감지를 할 수 없게 된다. <strong>일본어 윈도에서 압축한 <a title="→ zip" data-dead-href="/w/zip.ko" class="keyword dead">ZIP</a> 파일 열어 보면 이게 뭔 소린지 알 수 있게 된다.</strong></li>
</ul>
<p>세번째 문제는 너무 궤멸적인 까닭에 압축 해제 소프트웨어들이 웬만해서는 ZIP 파일의 인코딩을 사용자가 선택할 수 있게 하는데 큰 역할을 했다. 어찌 보면 잘 된 걸수도 있다(…). <a href="/w/windows-949.ko" title="→ windows-949" class="keyword">Windows-949</a> 인코딩은 여기에서 뼈저린 교훈을 얻고 좀 더 정상적인 설계를 사용하였다.</p>
<h2><span class="header-section-number">4</span> 같이 보기</h2>
<ul>
<li><a title="→ jis-x-0201" data-dead-href="/w/jis-x-0201.ko" class="keyword dead">JIS X 0201</a></li>
<li><a title="→ jis-x-0208" data-dead-href="/w/jis-x-0208.ko" class="keyword dead">JIS X 0208</a></li>
<li><a title="→ jis-x-0213" data-dead-href="/w/jis-x-0213.ko" class="keyword dead">JIS X 0213</a></li>
<li><a title="→ windows-31j" data-dead-href="/w/windows-31j.ko" class="keyword dead">Windows-31J</a></li>
</ul>
<section class="footnotes"><hr />
<section id="fn1"><h6>1</h6><p>사실 <a title="→ 제2차세계대전" data-dead-href="/w/%EC%A0%9C2%EC%B0%A8%EC%84%B8%EA%B3%84%EB%8C%80%EC%A0%84.ko" class="keyword dead">제2차 세계 대전</a> 이전의 공식 문서에서는 가타카나가 현재의 <a title="→ 히라가나" data-dead-href="/w/%ED%9E%88%EB%9D%BC%EA%B0%80%EB%82%98.ko" class="keyword dead">히라가나</a>의 자리를, 히라가나가 현재의 <a title="→ 칸지" data-dead-href="/w/%EC%B9%B8%EC%A7%80.ko" class="keyword dead">칸지</a>의 자리를 차지하고 있었으며, 1980년대까지만 해도 전산화가 필요한 곳(전보 등)에서는 가타카나가 기본으로 쓰였다. 어쩌면 JIS X 0201의 설계자들은 <a title="→ gb-2312" data-dead-href="/w/gb-2312.ko" class="keyword dead">GB 2312</a> 및 <a title="→ gb-t-12345" data-dead-href="/w/gb-t-12345.ko" class="keyword dead">GB/T 12345</a>와 같이 똑같은 매핑에 히라가나와 가타카나만 다른 문자 집합을 구상했을 지도 모른다. <a href="#fnref1" class="footnote-back">▲</a></p></section>
<section id="fn2"><h6>2</h6><p>실제로는 특수 문자는 NEC 특수 문자를 기준으로, 한자는 IBM 확장 한자를 기준으로 인코딩하고 나머지는 호환을 위해서만 유지한다. <a href="#fnref2" class="footnote-back">▲</a></p></section>
<section id="fn3"><h6>3</h6><p>심지어 <a href="/w/%EC%9C%A0%EB%8B%88%EC%BD%94%EB%93%9C.ko" title="→ 유니코드" class="keyword">유니코드</a>에 인코딩이 안 되어 있어서 유니코드 기반 글꼴로는 완벽한 지원이 불가능한 경우도 있다. MacJapanese가 그런 경우로, <a title="→ 오에스텐" data-dead-href="/w/%EC%98%A4%EC%97%90%EC%8A%A4%ED%85%90.ko" class="keyword dead">오에스텐</a>에 기본으로 들어 있는 <a title="→ ヒラギノ" data-dead-href="/w/%E3%83%92%E3%83%A9%E3%82%AE%E3%83%8E.ko" class="keyword dead">ヒラギノ</a> 계열의 글꼴이 이 이유로 일부 문자를 지원하지 않는다. 이게 무슨…. <a href="#fnref3" class="footnote-back">▲</a></p></section>
</section>
</main>
<footer>
<p id="mearie-meta"><code><i class="mearie-logo"></i>/sjis</code> | 마지막 수정 <time>2016-05-29T19:22:13+0000</time> (<code>12e94c38778d</code>)</p>
<address>저작권자 &copy; 1999&ndash;2016, 강 성훈. <a href="/about/copyright.ko" rel="copyright">저작권을 약간 가집니다.</a></address>
</footer>
</body>
</html>
